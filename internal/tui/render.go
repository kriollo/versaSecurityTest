package tui

import (
	"fmt"
	"strings"
	"time"

	"github.com/charmbracelet/lipgloss"
)

// renderHeader renderiza el header de la aplicaci√≥n
func (m Model) renderHeader() string {
	banner := `
‚ñà‚ñà‚ïó   ‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïê‚ïê‚ïù
‚ñà‚ñà‚ïë   ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó  ‚ñà‚ñà‚ïë
‚ïö‚ñà‚ñà‚ïó ‚ñà‚ñà‚ïî‚ïù‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïó‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ñà‚ñà‚ïë‚ïö‚ïê‚ïê‚ïê‚ïê‚ñà‚ñà‚ïë‚ñà‚ñà‚ïî‚ïê‚ïê‚ïù  ‚ñà‚ñà‚ïë
 ‚ïö‚ñà‚ñà‚ñà‚ñà‚ïî‚ïù ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ïë  ‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó‚ïö‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ïó
  ‚ïö‚ïê‚ïê‚ïê‚ïù  ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïù  ‚ïö‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù`

	head // Agregar indicadores de scro	// Agregar indicadores de scroll visuales e intuitivos
	scrollContent := strings.Join(visibleLines, "\n")
	if totalLines > availableHeight {
		// Indicadores llamativos arriba y abajo
		if m.scrollOffset > 0 {
			scrollContent = "‚ñ≤‚ñ≤‚ñ≤ HAY M√ÅS CONTENIDO ARRIBA - Presiona ‚Üë o PgUp ‚ñ≤‚ñ≤‚ñ≤\n" + scrollContent
		}

		if endLine < totalLines {
			scrollContent += "\n‚ñº‚ñº‚ñº HAY M√ÅS CONTENIDO ABAJO - Presiona ‚Üì o PgDn ‚ñº‚ñº‚ñº"
		}

		// Barra de progreso visual
		progressPercent := float64(endLine) / float64(totalLines) * 100
		progressBar := "["
		barWidth := 20
		filled := int(progressPercent / 100 * float64(barWidth))
		for i := 0; i < barWidth; i++ {
			if i < filled {
				progressBar += "‚ñà"
			} else {
				progressBar += "‚ñë"
			}
		}
		progressBar += "]"

		scrollContent += fmt.Sprintf("\n\nüìú SCROLL: %s %.1f%% | L√≠neas %d-%d de %d",
			progressBar, progressPercent, startLine+1, endLine, totalLines)
		scrollContent += fmt.Sprintf("\nüéÆ ‚Üë‚Üì L√≠nea | PgUp/PgDn P√°gina | Home/End Inicio/Final")
	}

	sb.WriteString(scrollContent)
	return sb.String()
}

// renderURLStep renderiza el paso de entrada de URL
		}
		progressBar += "]"

		// Informaci√≥n de navegaci√≥n detallada con estilo
		scrollContent += fmt.Sprintf("\n\nüìú NAVEGACI√ìN DE RESULTADOS:")
		scrollContent += fmt.Sprintf("\n   %s %.1f%% - Mostrando l√≠neas %d-%d de %d total",
			progressBar, float64(endLine)/float64(totalLines)*100, startLine+1, endLine, totalLines)
		scrollContent += fmt.Sprintf("\n   üéÆ ‚Üë‚Üì Scroll l√≠nea por l√≠nea | PgUp/PgDn Scroll p√°gina completa | Home/End Ir al inicio/final")

		// Indicador de posici√≥n espec√≠fico
		if m.scrollOffset == 0 {
			scrollContent += "\n   üìç Est√°s viendo el INICIO del reporte"
		} else if endLine >= totalLines {
			scrollContent += "\n   üìç Est√°s viendo el FINAL del reporte"
		} else {
			scrollContent += fmt.Sprintf("\n   üìç Posici√≥n actual: %.1f%% del reporte completo", float64(startLine+availableHeight/2)/float64(totalLines)*100)
		}
	}

	sb.WriteString(scrollContent)
	return sb.String()
}

// renderURLStep renderiza el paso de entrada de URL
func (m Model) renderURLStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 1: SELECCI√ìN DE PROTOCOLO"))
	sb.WriteString("\n\n")
	sb.WriteString("Seleccione el protocolo a usar:\n\n")

	// Opci√≥n HTTPS
	httpsMarker := "[ ]"
	if m.useHTTPS {
		httpsMarker = "[X]"
	}
	httpsStyle := normalStyle
	if m.useHTTPS {
		httpsStyle = focusedStyle
	}
	sb.WriteString(httpsStyle.Render(fmt.Sprintf("%s HTTPS (Recomendado)", httpsMarker)))
	sb.WriteString("\n")

	// Opci√≥n HTTP
	httpMarker := "[ ]"
	if !m.useHTTPS {
		httpMarker = "[X]"
	}
	httpStyle := normalStyle
	if !m.useHTTPS {
		httpStyle = focusedStyle
	}
	sb.WriteString(httpStyle.Render(fmt.Sprintf("%s HTTP", httpMarker)))
	sb.WriteString("\n\n")

	sb.WriteString("üí° Consejo: HTTPS es m√°s seguro y se recomienda para sitios de producci√≥n.\n")
	sb.WriteString("   Use HTTP solo para desarrollo local (localhost).\n")

	return sb.String()
}

// renderURLStep renderiza el paso de entrada de URL
func (m Model) renderURLStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 2: INGRESO DE URL"))
	sb.WriteString("\n\n")

	protocol := "https://"
	if !m.useHTTPS {
		protocol = "http://"
	}

	sb.WriteString(fmt.Sprintf("Protocolo seleccionado: %s\n\n", successStyle.Render(protocol)))
	sb.WriteString("Ingrese la URL objetivo (sin protocolo):\n")
	sb.WriteString("Ejemplos: localhost:8080, www.ejemplo.com, api.ejemplo.com/v1\n\n")

	// Campo de entrada
	urlField := lipgloss.NewStyle().
		Border(lipgloss.RoundedBorder()).
		BorderForeground(lipgloss.Color("#7D56F4")).
		Padding(0, 1).
		Width(50)

	fullURL := protocol + m.url
	if m.url == "" {
		fullURL = protocol + "‚ñã" // Cursor
	} else {
		fullURL += "‚ñã" // Cursor al final
	}

	sb.WriteString(urlField.Render(fullURL))
	sb.WriteString("\n\n")

	if m.url != "" {
		sb.WriteString(fmt.Sprintf("URL completa: %s\n", successStyle.Render(protocol+m.url)))
	}

	return sb.String()
}

// renderProfileStep renderiza el paso de selecci√≥n de perfil de escaneo
func (m Model) renderProfileStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 3: SELECCI√ìN DE PERFIL DE ESCANEO"))
	sb.WriteString("\n\n")

	protocol := "https://"
	if !m.useHTTPS {
		protocol = "http://"
	}

	sb.WriteString(fmt.Sprintf("üéØ URL objetivo: %s\n\n", successStyle.Render(protocol+m.url)))

	sb.WriteString("Seleccione el nivel de escaneo que desea realizar:\n\n")

	// Renderizar cada perfil
	for i, profile := range m.profiles {
		var style lipgloss.Style
		var marker string
		var prefix string

		if profile.Selected {
			marker = "[X]"
			style = focusedStyle
		} else {
			marker = "[ ]"
			style = normalStyle
		}

		if i == m.cursor {
			prefix = "‚Üí"
			style = style.Bold(true)
		} else {
			prefix = " "
		}

		// Formatear timeout
		timeoutStr := fmt.Sprintf("%.0fs", profile.Timeout.Seconds())

		sb.WriteString(style.Render(fmt.Sprintf("%s%s %s", prefix, marker, profile.Name)))
		sb.WriteString("\n")
		sb.WriteString(style.Render(fmt.Sprintf("     %s", profile.Description)))
		sb.WriteString("\n")
		sb.WriteString(style.Render(fmt.Sprintf("     üìä %d tests | ‚è±Ô∏è %s | üßµ %d hilos",
			profile.TestCount, timeoutStr, profile.Concurrent)))
		sb.WriteString("\n\n")
	}

	sb.WriteString("\n")
	sb.WriteString("üí° NAVEGACI√ìN: [‚Üë‚Üì] Perfil anterior/siguiente | [SPACE] Seleccionar | [Enter] Continuar\n")
	sb.WriteString("\n")
	sb.WriteString("üéÆ CONTROLES: ‚Üë‚Üì Navegar | Space Seleccionar | Enter Continuar | Esc Volver")

	return sb.String()
}

// renderTestsStep renderiza el paso de selecci√≥n de tests en columnas compactas
func (m Model) renderTestsStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 3: SELECCI√ìN DE TESTS DE SEGURIDAD OWASP"))
	sb.WriteString("\n\n")

	selectedCount := 0
	recommendedCount := 0
	for _, test := range m.tests {
		if test.Selected {
			selectedCount++
		}
		if test.Recommended {
			recommendedCount++
		}
	}

	url := "https://"
	if !m.useHTTPS {
		url = "http://"
	}
	url += m.url

	sb.WriteString(fmt.Sprintf("üéØ URL objetivo: %s\n", successStyle.Render(url)))
	sb.WriteString(fmt.Sprintf("üìä Tests seleccionados: %s | Recomendados: %d\n\n",
		successStyle.Render(fmt.Sprintf("%d/%d", selectedCount, len(m.tests))), recommendedCount))

	// Renderizar tests en columnas compactas
	sb.WriteString(m.renderTestsInColumns())

	// Mostrar descripci√≥n del test enfocado
	if m.cursor >= 0 && m.cursor < len(m.tests) {
		focusedTest := m.tests[m.cursor]
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render(fmt.Sprintf("üìã %s", focusedTest.Description)))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render(fmt.Sprintf("üè∑Ô∏è Categor√≠a: %s (%s)", focusedTest.Category, getCategoryDescription(focusedTest.Category))))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"))
		sb.WriteString("\n")
	}

	sb.WriteString("\n")
	if m.verbose {
		sb.WriteString("üîç Modo verbose: " + successStyle.Render("ACTIVADO") + " (mostrar√° detalles completos)\n")
	} else {
		sb.WriteString("üîç Modo verbose: DESACTIVADO (presione 'v' para activar)\n")
	}

	if m.useAdvancedTests {
		sb.WriteString("üöÄ Tests avanzados: " + successStyle.Render("ACTIVADOS") + " (t√©cnicas agresivas y evasi√≥n)\n")
	} else {
		sb.WriteString("ÔøΩ Tests avanzados: DESACTIVADOS (presione 'x' para activar)\n")
	}

	sb.WriteString("ÔøΩÔøΩ Atajos: [SPACE] Seleccionar | [A] Todos | [N] Ninguno | [R] Recomendados | [V] Verbose | [X] Avanzados\n")
	sb.WriteString("   ‚≠ê = Recomendado | ‚òë = Seleccionado | ‚Üí = Cursor actual\n")

	return sb.String()
}

// getCategoryDescription devuelve una descripci√≥n breve de la categor√≠a OWASP
func getCategoryDescription(category string) string {
	descriptions := map[string]string{
		"INFO": "Recolecci√≥n de Info",
		"CONF": "Configuraci√≥n",
		"IDNT": "Identidad",
		"ATHN": "Autenticaci√≥n",
		"ATHZ": "Autorizaci√≥n",
		"SESS": "Sesiones",
		"INPV": "Validaci√≥n Entrada",
		"ERRH": "Manejo Errores",
		"CRYP": "Criptograf√≠a",
		"BUSL": "L√≥gica Negocio",
		"CLNT": "Cliente",
		"APIT": "APIs",
		"MISC": "Adicionales",
	}

	if desc, exists := descriptions[category]; exists {
		return desc
	}
	return "Otros"
}

// getGlobalTestIndex encuentra el √≠ndice global de un test por su ID
func getGlobalTestIndex(tests []TestItem, id string) int {
	for i, test := range tests {
		if test.ID == id {
			return i
		}
	}
	return -1
}

// renderFormatStep renderiza el paso de selecci√≥n de formato
func (m Model) renderFormatStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 4: FORMATO DE SALIDA"))
	sb.WriteString("\n\n")

	for i, format := range m.formats {
		checkbox := "[ ]"
		if format.Selected {
			checkbox = "[X]"
		}

		style := normalStyle
		if m.cursor == i {
			style = focusedStyle
		} else if format.Selected {
			style = selectedStyle
		}

		line := fmt.Sprintf("%s %s", checkbox, format.Name)
		sb.WriteString(style.Render(line))
		sb.WriteString("\n")

		if m.cursor == i {
			desc := fmt.Sprintf("   üìù %s", format.Description)
			sb.WriteString(warningStyle.Render(desc))
			sb.WriteString("\n")
		}
		sb.WriteString("\n")
	}

	// Configuraciones adicionales
	sb.WriteString(titleStyle.Render("CONFIGURACIONES ADICIONALES"))
	sb.WriteString("\n\n")

	verboseCheckbox := "[ ]"
	if m.verbose {
		verboseCheckbox = "[X]"
	}
	verboseStyle := normalStyle
	if m.verbose {
		verboseStyle = selectedStyle
	}
	sb.WriteString(verboseStyle.Render(fmt.Sprintf("%s Modo Verbose (mostrar detalles adicionales)", verboseCheckbox)))
	sb.WriteString("\n\n")

	sb.WriteString("üí° Presione [V] para activar/desactivar el modo verbose en cualquier momento\n")

	return sb.String()
}

// renderConfirmStep renderiza el paso de confirmaci√≥n
func (m Model) renderConfirmStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("PASO 5: CONFIRMACI√ìN"))
	sb.WriteString("\n\n")

	// Resumen de configuraci√≥n
	protocol := "https://"
	if !m.useHTTPS {
		protocol = "http://"
	}

	sb.WriteString("üìã RESUMEN DE CONFIGURACI√ìN:\n")
	sb.WriteString(strings.Repeat("‚îÄ", 50) + "\n")
	sb.WriteString(fmt.Sprintf("üéØ URL Objetivo:     %s\n", successStyle.Render(protocol+m.url)))

	selectedTests := []string{}
	for _, test := range m.tests {
		if test.Selected {
			selectedTests = append(selectedTests, test.Name)
		}
	}
	sb.WriteString(fmt.Sprintf("üîç Tests (%d):        %s\n", len(selectedTests), strings.Join(selectedTests[:min(3, len(selectedTests))], ", ")))
	if len(selectedTests) > 3 {
		sb.WriteString(fmt.Sprintf("                     ... y %d m√°s\n", len(selectedTests)-3))
	}

	selectedFormat := ""
	for _, format := range m.formats {
		if format.Selected {
			selectedFormat = format.Name
			break
		}
	}
	sb.WriteString(fmt.Sprintf("üìä Formato:          %s\n", selectedFormat))
	sb.WriteString(fmt.Sprintf("üîç Modo Verbose:     %v\n", m.verbose))
	sb.WriteString(strings.Repeat("‚îÄ", 50) + "\n\n")

	// Opciones de confirmaci√≥n
	confirmStyle := normalStyle
	cancelStyle := normalStyle

	if m.cursor == 0 {
		confirmStyle = focusedStyle
	} else {
		cancelStyle = focusedStyle
	}

	sb.WriteString("¬øDesea proceder con el escaneo?\n\n")
	sb.WriteString(confirmStyle.Render("[ ] ‚úÖ Confirmar y ejecutar escaneo"))
	sb.WriteString("\n")
	sb.WriteString(cancelStyle.Render("[ ] ‚ùå Cancelar y volver atr√°s"))
	sb.WriteString("\n")

	return sb.String()
}

// renderScanningStep renderiza el paso de escaneo en progreso
func (m Model) renderScanningStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("üîç ESCANEO EN PROGRESO"))
	sb.WriteString("\n\n")

	// Mostrar informaci√≥n del objetivo
	protocol := "https://"
	if !m.useHTTPS {
		protocol = "http://"
	}
	fullURL := protocol + m.url

	sb.WriteString(fmt.Sprintf("üéØ Objetivo: %s\n", successStyle.Render(fullURL)))
	sb.WriteString(fmt.Sprintf("üìä Tests seleccionados: %d\n", countSelectedTests(m.tests)))

	// Mostrar tiempo transcurrido
	elapsed := time.Since(m.scanProgress.StartTime)
	sb.WriteString(fmt.Sprintf("‚è±Ô∏è  Tiempo transcurrido: %s\n", elapsed.Round(time.Second)))
	sb.WriteString("\n")

	// Mostrar progreso si est√° disponible
	if m.scanProgress.Total > 0 {
		percent := float64(m.scanProgress.Completed) / float64(m.scanProgress.Total) * 100
		sb.WriteString(fmt.Sprintf("üìà Progreso: %.1f%% [%d/%d]\n",
			percent, m.scanProgress.Completed, m.scanProgress.Total))

		// Barra de progreso visual
		progressBarWidth := 50
		filledWidth := int(percent / 100 * float64(progressBarWidth))
		emptyWidth := progressBarWidth - filledWidth

		progressBar := strings.Repeat("‚ñà", filledWidth) + strings.Repeat("‚ñë", emptyWidth)
		sb.WriteString(fmt.Sprintf("‚ñà%s‚ñà %.1f%%\n", progressBar, percent))
		sb.WriteString("\n")

		// Test actual si est√° disponible
		if m.scanProgress.CurrentTest != "" {
			sb.WriteString(fmt.Sprintf("üîÑ Test actual: %s\n", warningStyle.Render(m.scanProgress.CurrentTest)))
		}
	} else {
		// Spinner de carga si no hay progreso espec√≠fico
		spinners := []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"}
		spinner := spinners[int(elapsed.Seconds())%len(spinners)]
		sb.WriteString(fmt.Sprintf("%s Ejecutando tests de seguridad...\n", spinner))
	}

	sb.WriteString("\n")
	sb.WriteString(warningStyle.Render("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"))
	sb.WriteString("\n")
	sb.WriteString("üí° CONTROLES DURANTE EL ESCANEO:\n")
	sb.WriteString("   ‚Ä¢ Presiona 'S' para saltar el test actual\n")
	sb.WriteString("   ‚Ä¢ Presiona 'Q' o 'Esc' para cancelar el escaneo\n")
	sb.WriteString("   ‚Ä¢ Presiona 'V' para activar/desactivar modo verbose\n")
	sb.WriteString(warningStyle.Render("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"))

	return sb.String()
}

// renderFinishingStep renderiza el paso de finalizaci√≥n
func (m Model) renderFinishingStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("‚è≥ FINALIZANDO ESCANEO"))
	sb.WriteString("\n\n")

	// Spinner de finalizaci√≥n
	spinners := []string{"‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"}
	elapsed := time.Since(m.finishingStart)
	spinner := spinners[int(elapsed.Milliseconds()/100)%len(spinners)]

	sb.WriteString(fmt.Sprintf("%s Generando reporte y calculando puntuaci√≥n de seguridad...\n", spinner))
	sb.WriteString(fmt.Sprintf("‚è±Ô∏è  Tiempo de procesamiento: %s\n", elapsed.Round(time.Millisecond*100)))

	return sb.String()
}

// renderResultsStep renderiza el paso de resultados con scroll
func (m Model) renderResultsStep() string {
	var sb strings.Builder

	sb.WriteString(titleStyle.Render("üìä RESULTADOS DEL ESCANEO"))
	sb.WriteString("\n\n")

	if m.scanResult == nil {
		sb.WriteString(errorStyle.Render("No hay resultados disponibles"))
		return sb.String()
	}

	// Generar todo el contenido primero
	var fullContent strings.Builder

	// Resumen principal
	fullContent.WriteString("üìã RESUMEN EJECUTIVO:\n")
	fullContent.WriteString(strings.Repeat("‚ïê", 60) + "\n")

	protocol := "https://"
	if !m.useHTTPS {
		protocol = "http://"
	}

	fullContent.WriteString(fmt.Sprintf("üéØ URL Escaneada:    %s\n", protocol+m.url))
	fullContent.WriteString(fmt.Sprintf("üìÖ Fecha/Hora:       %s\n", m.scanResult.ScanDate.Format("2006-01-02 15:04:05")))
	fullContent.WriteString(fmt.Sprintf("‚è±Ô∏è  Duraci√≥n:         %v\n", m.scanResult.Duration.Round(time.Millisecond)))
	fullContent.WriteString(fmt.Sprintf("üîç Tests Ejecutados: %d\n", m.scanResult.TestsExecuted))
	fullContent.WriteString(fmt.Sprintf("‚úÖ Tests Pasados:    %s\n", successStyle.Render(fmt.Sprintf("%d", m.scanResult.TestsPassed))))
	fullContent.WriteString(fmt.Sprintf("‚ùå Tests Fallidos:   %s\n", errorStyle.Render(fmt.Sprintf("%d", m.scanResult.TestsFailed))))
	fullContent.WriteString(strings.Repeat("‚ïê", 60) + "\n\n")

	// Puntuaci√≥n de seguridad
	score := m.scanResult.SecurityScore.Value
	risk := m.scanResult.SecurityScore.Risk

	scoreStyle := successStyle
	if score < 7.0 {
		scoreStyle = warningStyle
	}
	if score < 4.0 {
		scoreStyle = errorStyle
	}

	fullContent.WriteString("üõ°Ô∏è  PUNTUACI√ìN DE SEGURIDAD:\n")
	fullContent.WriteString(strings.Repeat("‚îÄ", 30) + "\n")
	fullContent.WriteString(fmt.Sprintf("Puntuaci√≥n: %s/10\n", scoreStyle.Render(fmt.Sprintf("%.1f", score))))
	fullContent.WriteString(fmt.Sprintf("Nivel de Riesgo: %s\n\n", scoreStyle.Render(risk)))

	// Resultados resumidos por categor√≠a
	if len(m.scanResult.TestResults) > 0 {
		fullContent.WriteString("üìù RESULTADOS POR TEST:\n")
		fullContent.WriteString(strings.Repeat("‚îÄ", 40) + "\n")

		for _, result := range m.scanResult.TestResults {
			status := errorStyle.Render("‚ùå FALL√ì")
			if result.Status == "Passed" {
				status = successStyle.Render("‚úÖ PAS√ì")
			}

			fullContent.WriteString(fmt.Sprintf("%s %s\n", status, result.TestName))
			if result.Description != "" && result.Status != "Passed" {
				fullContent.WriteString(fmt.Sprintf("    %s\n", warningStyle.Render(result.Description)))
			}

			// Agregar detalle adicional cuando el test falla
			if result.Status == "Failed" && len(result.Evidence) > 0 {
				fullContent.WriteString("    üî¥ Detalles del fallo:\n")

				// Mostrar la primera evidencia como ejemplo
				evidence := result.Evidence[0]
				fullContent.WriteString(fmt.Sprintf("      üìù Tipo: %s\n", errorStyle.Render(evidence.Type)))
				fullContent.WriteString(fmt.Sprintf("      üí¨ Payload: %s\n", warningStyle.Render(evidence.Payload)))
				fullContent.WriteString(fmt.Sprintf("      üìû Respuesta: %s\n", normalStyle.Render(evidence.Response)))

				if len(result.Evidence) > 1 {
					fullContent.WriteString(fmt.Sprintf("      ‚ÑπÔ∏è  ... y %d evidencias m√°s (ver detalles completos)\n", len(result.Evidence)-1))
				}
				fullContent.WriteString("\n")
			} else if result.Status == "Failed" {
				// Fallback si no hay evidencias espec√≠ficas
				fullContent.WriteString("    üî¥ Ejemplos de lo que se detect√≥:\n")
				switch result.TestName {
				case "SQL Injection":
					fullContent.WriteString(fmt.Sprintf("      üí¨ Payload usado: %s\n", warningStyle.Render("' OR '1'='1")))
					fullContent.WriteString(fmt.Sprintf("      üìû Respuesta: %s\n", errorStyle.Render("Error SQL o comportamiento anormal")))
				case "Cross-Site Scripting":
					fullContent.WriteString(fmt.Sprintf("      üí¨ Payload usado: %s\n", warningStyle.Render("<script>alert('XSS')</script>")))
					fullContent.WriteString(fmt.Sprintf("      üìû Respuesta: %s\n", errorStyle.Render("Script reflejado sin sanitizaci√≥n")))
				case "Headers de Seguridad":
					fullContent.WriteString(fmt.Sprintf("      üí¨ Header faltante: %s\n", warningStyle.Render("X-Frame-Options")))
					fullContent.WriteString(fmt.Sprintf("      üìû Riesgo: %s\n", errorStyle.Render("Posible clickjacking")))
				default:
					fullContent.WriteString(fmt.Sprintf("      üìû Resultado: %s\n", errorStyle.Render("Vulnerabilidad detectada")))
				}
				fullContent.WriteString("\n")
			}
		}
		fullContent.WriteString("\n")
	}

	// Recomendaciones principales
	if len(m.scanResult.Recommendations) > 0 {
		fullContent.WriteString("üí° RECOMENDACIONES PRINCIPALES:\n")
		fullContent.WriteString(strings.Repeat("‚îÄ", 40) + "\n")
		maxRecs := min(5, len(m.scanResult.Recommendations))
		for i := 0; i < maxRecs; i++ {
			fullContent.WriteString(fmt.Sprintf("%d. %s\n", i+1, m.scanResult.Recommendations[i]))
		}
		if len(m.scanResult.Recommendations) > 5 {
			fullContent.WriteString(fmt.Sprintf("   ... y %d recomendaciones m√°s (ver detalles)\n", len(m.scanResult.Recommendations)-5))
		}
		fullContent.WriteString("\n")
	}

	fullContent.WriteString("üéÆ OPCIONES:\n")
	fullContent.WriteString("   [D/Enter] Ver detalles completos\n")
	fullContent.WriteString("   [R] Repetir escaneo\n")
	fullContent.WriteString("   [S] Guardar reporte\n")
	fullContent.WriteString("   [Backspace] Nuevo escaneo\n")
	fullContent.WriteString("   [Q/Esc] Salir\n")

	// Aplicar scroll - dividir contenido en l√≠neas
	lines := strings.Split(fullContent.String(), "\n")
	totalLines := len(lines)

	// Calcular cu√°ntas l√≠neas caben en la pantalla (reservar espacio para header y footer)
	availableHeight := m.height - 6 // Header + footer + m√°rgenes
	if availableHeight < 10 {
		availableHeight = 10 // M√≠nimo
	}

	// Ajustar scrollOffset para no ir m√°s all√° del contenido
	maxScroll := totalLines - availableHeight
	if maxScroll < 0 {
		maxScroll = 0
	}
	if m.scrollOffset > maxScroll {
		// Actualizar el modelo (necesario para reflejar el cambio)
		// Nota: Esto es un poco hacky, pero necesario para limitar el scroll
		m.scrollOffset = maxScroll
	}

	// Seleccionar las l√≠neas visibles
	startLine := m.scrollOffset
	endLine := startLine + availableHeight
	if endLine > totalLines {
		endLine = totalLines
	}

	visibleLines := lines[startLine:endLine]

	// Agregar indicador de scroll si es necesario
	scrollContent := strings.Join(visibleLines, "\n")
	if totalLines > availableHeight {
		scrollContent += fmt.Sprintf("\n\nüí° NAVEGACI√ìN: [‚Üë‚Üì] L√≠nea | [PgUp/PgDn] P√°gina | [Home/End] Inicio/Final | L√≠nea %d-%d de %d",
			startLine+1, endLine, totalLines)
	}

	sb.WriteString(scrollContent)
	return sb.String()
}

// renderFooter renderiza el footer con ayuda
func (m Model) renderFooter() string {
	var help strings.Builder

	help.WriteString("üéÆ CONTROLES: ")

	switch m.state {
	case StateProtocol:
		help.WriteString("‚Üë‚Üì Navegar | Space Seleccionar | Enter Continuar | Q Salir")
	case StateURL:
		help.WriteString("Escribir URL | Enter Continuar | Esc Volver | Q Salir")
	case StateTests:
		help.WriteString("‚Üë‚Üì Navegar | PgUp/PgDn P√°gina | Space Seleccionar | A Todos | N Ninguno | R Recomendados | V Verbose | X Avanzados | Enter Continuar")
	case StateFormat:
		help.WriteString("‚Üë‚Üì Navegar | Space Seleccionar | V Verbose | Enter Continuar")
	case StateConfirm:
		help.WriteString("‚Üë‚Üì Navegar | Space Seleccionar | Enter Confirmar | Esc Volver")
	case StateScanning:
		help.WriteString("Q Cancelar escaneo")
	case StateFinishing:
		help.WriteString("Generando reporte... Por favor espere")
	case StateResults:
		help.WriteString("‚Üë‚Üì Scroll | PgUp/PgDn P√°gina | D Detalles | R Repetir | S Guardar | Backspace Nuevo | Q Salir")
	}

	if m.verbose {
		help.WriteString(" | üîç VERBOSE ACTIVO")
	}

	footerStyle := lipgloss.NewStyle().
		Foreground(lipgloss.Color("#888888")).
		Background(lipgloss.Color("#1a1a1a")).
		Padding(0, 1)

	return footerStyle.Render(help.String())
}

// renderModal renderiza un modal sobre el contenido principal
func (m Model) renderModal(content string) string {
	// Crear el contenido del modal
	modalWidth := min(m.width-10, 100)
	modalHeight := min(m.height-10, 30)

	// Procesar el contenido para que quepa en el modal
	lines := strings.Split(m.modalContent, "\n")
	modalLines := []string{}

	for _, line := range lines {
		if len(line) <= modalWidth-4 {
			modalLines = append(modalLines, line)
		} else {
			// Partir l√≠neas largas
			for len(line) > modalWidth-4 {
				modalLines = append(modalLines, line[:modalWidth-4])
				line = line[modalWidth-4:]
			}
			if len(line) > 0 {
				modalLines = append(modalLines, line)
			}
		}

		if len(modalLines) >= modalHeight-4 {
			modalLines = append(modalLines, "... (contenido truncado)")
			break
		}
	}

	modalContent := strings.Join(modalLines, "\n")

	// Crear el modal
	modal := modalStyle.
		Width(modalWidth).
		Height(modalHeight).
		Render(fmt.Sprintf("%s\n\n%s\n\n%s",
			titleStyle.Render(m.modalTitle),
			modalContent,
			normalStyle.Render("Presione ESC o Q para cerrar")))

	// Posicionar el modal en el centro
	_ = (m.width - modalWidth) / 2   // modalX no se usa
	_ = (m.height - modalHeight) / 2 // modalY no se usa

	// Crear el overlay
	overlay := lipgloss.Place(m.width, m.height, lipgloss.Center, lipgloss.Center, modal)

	return overlay
}

// min retorna el menor de dos enteros
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}

// renderTestsInColumns renderiza los tests en formato de columnas compactas con scroll
func (m Model) renderTestsInColumns() string {
	var sb strings.Builder

	// Asegurar que el modelo tenga scroll configurado
	model := m.adjustScrollPosition()

	// Configuraci√≥n de visualizaci√≥n
	testsToShow := model.testsPerPage
	if testsToShow == 0 {
		testsToShow = max(5, model.height-25) // Fallback
	}

	// Determinar qu√© tests mostrar basado en el scroll
	startIndex := model.scrollOffset
	endIndex := min(len(model.tests), startIndex+testsToShow)

	// Mostrar indicador de scroll si es necesario
	if model.showScrollbar && len(model.tests) > testsToShow {
		totalTests := len(model.tests)
		currentPos := startIndex + 1
		endPos := min(totalTests, startIndex+testsToShow)

		sb.WriteString(fmt.Sprintf("üìÑ Mostrando tests %d-%d de %d total",
			currentPos, endPos, totalTests))

		// Barra de scroll visual
		scrollBarWidth := 20
		scrollProgress := float64(startIndex) / float64(totalTests-testsToShow)
		scrollPos := int(scrollProgress * float64(scrollBarWidth))

		scrollBar := strings.Repeat("‚îÄ", scrollPos) + "‚ñà" + strings.Repeat("‚îÄ", scrollBarWidth-scrollPos)
		sb.WriteString(fmt.Sprintf(" [%s]\n", scrollBar))
		sb.WriteString("\n")
	}

	// Configuraci√≥n de columnas
	columnsCount := 2       // Reducir a 2 columnas para m√°s espacio
	maxTestNameLength := 35 // Aumentar longitud del nombre

	// Crear una lista simple de tests a mostrar
	visibleTests := model.tests[startIndex:endIndex]

	// Renderizar en columnas simples
	for i := 0; i < len(visibleTests); i += columnsCount {
		for col := 0; col < columnsCount; col++ {
			if i+col >= len(visibleTests) {
				break
			}

			test := visibleTests[i+col]
			globalIndex := startIndex + i + col // √çndice real en la lista completa

			// Crear el contenido del test
			marker := "‚òê"
			if test.Selected {
				marker = "‚òë"
			}

			recommended := ""
			if test.Recommended {
				recommended = " ‚≠ê"
			}

			// Truncar nombre si es muy largo
			testName := test.Name
			if len(testName) > maxTestNameLength {
				testName = testName[:maxTestNameLength-3] + "..."
			}

			// Determinar estilo
			style := normalStyle
			prefix := " "
			if globalIndex == model.cursor {
				style = focusedStyle
				prefix = "‚Üí"
			}

			// Crear la l√≠nea del test con padding fijo
			testLine := fmt.Sprintf("%s%s %s%s", prefix, marker, testName, recommended)
			paddedLine := fmt.Sprintf("%-50s", testLine) // Padding fijo de 50 caracteres

			sb.WriteString(style.Render(paddedLine))

			// Agregar separador entre columnas (excepto en la √∫ltima)
			if col < columnsCount-1 && i+col+1 < len(visibleTests) {
				sb.WriteString(" | ")
			}
		}
		sb.WriteString("\n")
	}

	// Mostrar descripci√≥n del test enfocado
	if model.cursor >= 0 && model.cursor < len(model.tests) {
		focusedTest := model.tests[model.cursor]
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render(fmt.Sprintf("üìã %s", focusedTest.Description)))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render(fmt.Sprintf("üè∑Ô∏è Categor√≠a: %s (%s)", focusedTest.Category, getCategoryDescription(focusedTest.Category))))
		sb.WriteString("\n")
		sb.WriteString(warningStyle.Render("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"))
		sb.WriteString("\n")
	}

	// Mostrar controles de scroll si es necesario
	if model.showScrollbar {
		sb.WriteString("\nüí° NAVEGACI√ìN: [‚Üë‚Üì] Test anterior/siguiente | [PgUp/PgDn] P√°gina anterior/siguiente | [Home/End] Inicio/Final\n")
	}

	return sb.String()
}
